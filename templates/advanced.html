<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PiDog Advanced Control - D√©tection d'Obstacles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            grid-column: 1 / -1;
        }

        h2 {
            margin-bottom: 15px;
            color: #ffd700;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 5px;
        }

        .joystick-container {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .joystick {
            width: 150px;
            height: 150px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
            background: rgba(0,0,0,0.2);
            cursor: pointer;
            margin: 10px;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            background: #ffd700;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .joystick-label {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }

        .control-group {
            margin: 15px 0;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
        }

        .btn-info {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #9E9E9E, #757575);
        }

        .status-display {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
        }

        .obstacle-warning {
            background: linear-gradient(45deg, #ff5722, #d84315);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
            display: none;
        }

        .distance-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .distance-input input {
            padding: 8px;
            border: none;
            border-radius: 5px;
            width: 80px;
            text-align: center;
            font-size: 16px;
        }

        .distance-input label {
            font-weight: bold;
        }

        .sensor-panel {
            grid-column: 1 / -1;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .sensor-card {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .sensor-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
            margin: 10px 0;
        }

        .scan-visualization {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
        }

        .scan-angles {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }

        .angle-reading {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
            min-width: 60px;
            text-align: center;
        }

        .angle-reading.safe {
            background: rgba(76, 175, 80, 0.3);
        }

        .angle-reading.warning {
            background: rgba(255, 152, 0, 0.3);
        }

        .angle-reading.danger {
            background: rgba(244, 67, 54, 0.3);
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }

            .joystick-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêï PiDog Advanced Control</h1>

        <!-- Contr√¥le de Mouvement -->
        <div class="panel">
            <h2>üéÆ Contr√¥le de Mouvement</h2>

            <div class="joystick-container">
                <div>
                    <div class="joystick" id="movementJoystick">
                        <div class="joystick-knob" id="movementKnob"></div>
                    </div>
                    <div class="joystick-label">D√©placement</div>
                </div>

                <div>
                    <div class="joystick" id="headJoystick">
                        <div class="joystick-knob" id="headKnob"></div>
                    </div>
                    <div class="joystick-label">T√™te</div>
                </div>
            </div>

            <div class="obstacle-warning" id="obstacleWarning">
                ‚ö†Ô∏è OBSTACLE D√âTECT√â - Mouvement bloqu√©
            </div>

            <!-- Contr√¥le de Distance -->
            <div class="control-group">
                <h3>üìè Mouvement par Distance</h3>
                <div class="distance-input">
                    <label>Distance:</label>
                    <input type="number" id="distanceInput" value="1.0" min="0.1" max="10" step="0.1">
                    <label>m√®tres</label>
                </div>
                <button class="btn btn-info" onclick="moveDistance('forward')">
                    ‚¨ÜÔ∏è Avancer
                </button>
                <button class="btn btn-warning" onclick="moveDistance('backward')">
                    ‚¨áÔ∏è Reculer
                </button>
            </div>

            <!-- Actions du Robot -->
            <div class="control-group">
                <h3>üé≠ Actions</h3>
                <button class="btn" onclick="performAction('sit')">Assis</button>
                <button class="btn" onclick="performAction('stand_up')">Debout</button>
                <button class="btn" onclick="performAction('lie_down')">Couch√©</button>
                <button class="btn" onclick="performAction('wag_tail')">Remuer Queue</button>
                <button class="btn" onclick="performAction('stretch')">S'√©tirer</button>
                <button class="btn" onclick="performAction('shake_head')">Secouer T√™te</button>
            </div>

            <!-- Contr√¥les Sp√©ciaux -->
            <div class="control-group">
                <h3>üîä Sons & Modes</h3>
                <button class="btn btn-secondary" onclick="bark()">üîä Aboyer</button>
                <button class="btn btn-secondary" onclick="pant()">üò§ Haleter</button>
                <button class="btn btn-secondary" onclick="scratch()">üêæ Gratter</button>
                <button class="btn btn-info" id="autonomousBtn" onclick="toggleAutonomous()">
                    ü§ñ Mode Auto: OFF
                </button>
            </div>
        </div>

        <!-- D√©tection d'Obstacles -->
        <div class="panel">
            <h2>üõ°Ô∏è D√©tection d'Obstacles</h2>

            <button class="btn btn-info" onclick="scanObstacles()">
                üîç Scanner Environnement
            </button>

            <div class="scan-visualization" id="scanVisualization">
                <h4>Vision 360¬∞ du Robot</h4>
                <div class="scan-angles" id="scanAngles">
                    <div class="angle-reading" data-angle="-45">
                        <div>-45¬∞</div>
                        <div id="dist-45">--</div>
                    </div>
                    <div class="angle-reading" data-angle="-30">
                        <div>-30¬∞</div>
                        <div id="dist-30">--</div>
                    </div>
                    <div class="angle-reading" data-angle="0">
                        <div>0¬∞ (Face)</div>
                        <div id="dist0">--</div>
                    </div>
                    <div class="angle-reading" data-angle="30">
                        <div>+30¬∞</div>
                        <div id="dist30">--</div>
                    </div>
                    <div class="angle-reading" data-angle="45">
                        <div>+45¬∞</div>
                        <div id="dist45">--</div>
                    </div>
                </div>
                <div id="safeDirection">Direction s√ªre: En attente de scan...</div>
            </div>

            <div class="status-display">
                <h4>üìä √âtat du Syst√®me</h4>
                <div class="status-item">
                    <span>Connexion:</span>
                    <span id="connectionStatus">üî¥ D√©connect√©</span>
                </div>
                <div class="status-item">
                    <span>Distance Frontale:</span>
                    <span id="frontDistance">-- cm</span>
                </div>
                <div class="status-item">
                    <span>Obstacle D√©tect√©:</span>
                    <span id="obstacleStatus">Non</span>
                </div>
                <div class="status-item">
                    <span>Position Robot:</span>
                    <span id="robotStatus">Inconnu</span>
                </div>
                <div class="status-item">
                    <span>Mode Autonome:</span>
                    <span id="autonomousStatus">Inactif</span>
                </div>
            </div>
        </div>

        <!-- Informations Capteurs -->
        <div class="panel sensor-panel">
            <h2>üì° Capteurs en Temps R√©el</h2>
            <div class="sensor-grid">
                <div class="sensor-card">
                    <h4>Distance Ultrasonique</h4>
                    <div class="sensor-value" id="ultrasonicValue">-- cm</div>
                    <div id="ultrasonicStatus">En attente...</div>
                </div>
                <div class="sensor-card">
                    <h4>Seuil de S√©curit√©</h4>
                    <div class="sensor-value">25 cm</div>
                    <div>Distance minimale</div>
                </div>
                <div class="sensor-card">
                    <h4>Statut Mouvement</h4>
                    <div class="sensor-value" id="movementStatus">üõë</div>
                    <div id="movementText">Arr√™t√©</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let isMoving = false;
        let autonomousMode = false;
        let lastObstacleCheck = 0;

        // Configuration des joysticks
        class JoystickController {
            constructor(containerElement, knobElement, callback) {
                this.container = containerElement;
                this.knob = knobElement;
                this.callback = callback;
                this.isDragging = false;
                this.centerX = 0;
                this.centerY = 0;
                this.maxDistance = 0;

                this.setupEvents();
                this.calculateCenter();
            }

            calculateCenter() {
                const rect = this.container.getBoundingClientRect();
                this.centerX = rect.width / 2;
                this.centerY = rect.height / 2;
                this.maxDistance = Math.min(this.centerX, this.centerY) - 20;
            }

            setupEvents() {
                this.container.addEventListener('mousedown', this.startDrag.bind(this));
                this.container.addEventListener('touchstart', this.startDrag.bind(this));
                document.addEventListener('mousemove', this.drag.bind(this));
                document.addEventListener('touchmove', this.drag.bind(this));
                document.addEventListener('mouseup', this.stopDrag.bind(this));
                document.addEventListener('touchend', this.stopDrag.bind(this));
            }

            startDrag(e) {
                e.preventDefault();
                this.isDragging = true;
                this.drag(e);
            }

            drag(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const rect = this.container.getBoundingClientRect();

                let x = clientX - rect.left - this.centerX;
                let y = clientY - rect.top - this.centerY;

                const distance = Math.sqrt(x * x + y * y);
                if (distance > this.maxDistance) {
                    x = (x / distance) * this.maxDistance;
                    y = (y / distance) * this.maxDistance;
                }

                this.knob.style.transform = `translate(${x + this.centerX - 20}px, ${y + this.centerY - 20}px)`;

                // Calcul des valeurs normalis√©es
                const normalizedX = x / this.maxDistance;
                const normalizedY = -y / this.maxDistance; // Inverser Y pour correspondre aux conventions
                const intensity = Math.min(distance / this.maxDistance, 1);
                const angle = Math.atan2(-y, x) * 180 / Math.PI;
                const adjustedAngle = (90 - angle + 360) % 360; // Ajuster pour que 0¬∞ soit vers le haut

                this.callback({
                    x: normalizedX,
                    y: normalizedY,
                    intensity: intensity,
                    angle: adjustedAngle
                });
            }

            stopDrag() {
                if (!this.isDragging) return;
                this.isDragging = false;

                // Remettre le joystick au centre
                this.knob.style.transform = `translate(${this.centerX - 20}px, ${this.centerY - 20}px)`;

                this.callback({
                    x: 0,
                    y: 0,
                    intensity: 0,
                    angle: 0
                });
            }
        }

        // Initialisation des joysticks
        const movementJoystick = new JoystickController(
            document.getElementById('movementJoystick'),
            document.getElementById('movementKnob'),
            handleMovementJoystick
        );

        const headJoystick = new JoystickController(
            document.getElementById('headJoystick'),
            document.getElementById('headKnob'),
            handleHeadJoystick
        );

        // Gestionnaires de joysticks
        function handleMovementJoystick(data) {
            if (data.intensity > 0.1) {
                sendCommand({
                    angle: data.angle,
                    intensity: data.intensity
                });
            } else {
                sendCommand({
                    angle: 0,
                    intensity: 0
                });
            }
        }

        function handleHeadJoystick(data) {
            const qx = data.x * 100;
            const qy = data.y * 100;

            fetch('/head_control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ qx: qx, qy: qy })
            });
        }

        // Envoi des commandes de mouvement
        function sendCommand(data) {
            fetch('/command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                if (result.status === 'warning') {
                    // Obstacle d√©tect√©
                    showObstacleWarning(true);
                    updateMovementStatus('üõë Bloqu√©', 'Obstacle d√©tect√©');
                } else if (result.status === 'success') {
                    showObstacleWarning(false);
                    if (data.intensity > 0.1) {
                        updateMovementStatus('üèÉ En mouvement', result.message);
                    } else {
                        updateMovementStatus('üõë Arr√™t√©', 'Repos');
                    }
                }
            })
            .catch(error => console.error('Erreur commande:', error));
        }

        // Mouvement par distance
        function moveDistance(direction) {
            const distance = parseFloat(document.getElementById('distanceInput').value);

            if (distance <= 0 || distance > 10) {
                alert('Distance invalide (0.1 - 10 m√®tres)');
                return;
            }

            updateMovementStatus('üöÄ Mouvement programm√©', `${direction} ${distance}m`);

            fetch('/move_distance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    distance: distance,
                    direction: direction
                })
            })
            .then(response => response.json())
            .then(result => {
                if (result.status === 'success') {
                    updateMovementStatus('‚úÖ Termin√©', result.message);
                } else {
                    updateMovementStatus('‚ùå √âchec', result.message);
                }
            })
            .catch(error => {
                console.error('Erreur mouvement distance:', error);
                updateMovementStatus('‚ùå Erreur', '√âchec de communication');
            });
        }

        // Scan des obstacles
        function scanObstacles() {
            updateMovementStatus('üîç Scan en cours', 'Analyse environnement');

            fetch('/scan_obstacles')
            .then(response => response.json())
            .then(result => {
                if (result.status === 'success') {
                    updateScanVisualization(result);
                    updateMovementStatus('üì° Scan termin√©', 'Donn√©es mises √† jour');
                }
            })
            .catch(error => {
                console.error('Erreur scan:', error);
                updateMovementStatus('‚ùå Erreur scan', '√âchec de communication');
            });
        }

        // Mise √† jour de la visualisation du scan
        function updateScanVisualization(scanData) {
            const distances = scanData.distances;
            const threshold = scanData.obstacle_threshold;

            // Mise √† jour des lectures d'angles
            for (const [angle, distance] of Object.entries(distances)) {
                const elementId = `dist${angle.replace('-', '')}`;
                const element = document.getElementById(elementId);

                if (element) {
                    element.textContent = `${distance.toFixed(1)}cm`;

                    // Colorisation selon la distance
                    const angleElement = element.parentElement;
                    angleElement.className = 'angle-reading';

                    if (distance < threshold) {
                        angleElement.classList.add('danger');
                    } else if (distance < threshold * 1.5) {
                        angleElement.classList.add('warning');
                    } else {
                        angleElement.classList.add('safe');
                    }
                }
            }

            // Mise √† jour de la direction s√ªre
            const safeDirectionElement = document.getElementById('safeDirection');
            if (scanData.safe_direction) {
                const directionMap = {
                    'turn_left': '‚¨ÖÔ∏è Tourner √† gauche',
                    'turn_right': '‚û°Ô∏è Tourner √† droite',
                    'backward': '‚¨áÔ∏è Reculer',
                    'forward': '‚¨ÜÔ∏è Avancer libre'
                };

                safeDirectionElement.textContent =
                    `Direction s√ªre: ${directionMap[scanData.safe_direction] || scanData.safe_direction}
                     (${scanData.safe_distance.toFixed(1)}cm)`;
            } else {
                safeDirectionElement.textContent = 'Direction s√ªre: Aucune direction claire';
            }
        }

        // Actions du robot
        function performAction(action) {
            fetch('/action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: action })
            })
            .then(response => response.json())
            .then(result => {
                updateMovementStatus('üé≠ Action', result.message);
            })
            .catch(error => console.error('Erreur action:', error));
        }

        // Sons
        function bark() {
            fetch('/bark', { method: 'POST' })
            .then(response => response.json())
            .then(result => updateMovementStatus('üîä Son', result.message));
        }

        function pant() {
            fetch('/pant', { method: 'POST' })
            .then(response => response.json())
            .then(result => updateMovementStatus('üò§ Son', result.message));
        }

        function scratch() {
            fetch('/scratch', { method: 'POST' })
            .then(response => response.json())
            .then(result => updateMovementStatus('üêæ Action', result.message));
        }

        // Mode autonome
        function toggleAutonomous() {
            autonomousMode = !autonomousMode;

            fetch('/autonomous_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: autonomousMode })
            })
            .then(response => response.json())
            .then(result => {
                autonomousMode = result.enabled;
                const btn = document.getElementById('autonomousBtn');
                btn.textContent = `ü§ñ Mode Auto: ${autonomousMode ? 'ON' : 'OFF'}`;
                btn.className = autonomousMode ? 'btn btn-danger' : 'btn btn-info';

                document.getElementById('autonomousStatus').textContent =
                    autonomousMode ? 'üü¢ Actif' : 'üî¥ Inactif';
            });
        }

        // Affichage alerte obstacle
        function showObstacleWarning(show) {
            const warning = document.getElementById('obstacleWarning');
            warning.style.display = show ? 'block' : 'none';
        }

        // Mise √† jour du statut de mouvement
        function updateMovementStatus(status, message) {
            document.getElementById('movementStatus').textContent = status;
            document.getElementById('movementText').textContent = message;
        }

        // Mise √† jour des donn√©es capteurs
        function updateSensorData() {
            fetch('/sensor_data')
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    // Distance ultrasonique
                    const distance = data.distance;
                    document.getElementById('frontDistance').textContent = `${distance} cm`;
                    document.getElementById('ultrasonicValue').textContent = `${distance} cm`;

                    // Statut obstacle
                    const obstacleDetected = data.obstacle_detected;
                    document.getElementById('obstacleStatus').textContent =
                        obstacleDetected ? '‚ö†Ô∏è Oui' : '‚úÖ Non';

                    // Statut ultrasonique
                    const ultrasonicStatus = document.getElementById('ultrasonicStatus');
                    if (distance < 25) {
                        ultrasonicStatus.textContent = '‚ö†Ô∏è Obstacle proche';
                        ultrasonicStatus.style.color = '#ff5722';
                    } else if (distance < 50) {
                        ultrasonicStatus.textContent = '‚ö° Attention';
                        ultrasonicStatus.style.color = '#ff9800';
                    } else {
                        ultrasonicStatus.textContent = '‚úÖ Zone libre';
                        ultrasonicStatus.style.color = '#4caf50';
                    }

                    // Position robot
                    const statusMap = {0: 'Debout', 1: 'Assis', 2: 'Couch√©'};
                    document.getElementById('robotStatus').textContent =
                        statusMap[data.status] || 'Inconnu';
                }
            })
            .catch(error => {
                document.getElementById('ultrasonicStatus').textContent = '‚ùå Erreur capteur';
            });
        }

        // V√©rification du statut g√©n√©ral
        function updateSystemStatus() {
            fetch('/status')
            .then(response => response.json())
            .then(data => {
                if (data.status === 'connected') {
                    document.getElementById('connectionStatus').textContent = 'üü¢ Connect√©';
                } else {
                    document.getElementById('connectionStatus').textContent = 'üî¥ D√©connect√©';
                }

                // Mode autonome
                if (data.autonomous_mode !== undefined) {
                    autonomousMode = data.autonomous_mode;
                    document.getElementById('autonomousStatus').textContent =
                        autonomousMode ? 'üü¢ Actif' : 'üî¥ Inactif';
                }
            })
            .catch(error => {
                document.getElementById('connectionStatus').textContent = 'üî¥ Erreur';
            });
        }

        // Initialisation et boucles de mise √† jour
        document.addEventListener('DOMContentLoaded', function() {
            // Mise √† jour initiale
            updateSystemStatus();
            updateSensorData();

            // Mise √† jour p√©riodique des capteurs
            setInterval(updateSensorData, 500);  // Toutes les 500ms
            setInterval(updateSystemStatus, 2000);  // Toutes les 2s
        });
    </script>
</body>
</html>